1. 분할정복 (Divide & Conquer)
	<분할정복 조건>
		1) 문제를 둘 이상으로 나누는 자연스러운 방법이 존재해야 함
		2) 부분문제의 답을 조합해 원래 문제의 답을 계산하는 효율적 방법이 존재해야 함

	<필수요소>
	 - 재귀 호출과 비슷... (재귀를 써서 동작하니까 대부분..)
		1) Divide : 문제를 더 작은 문제로 분할
		2) Merge : 각 문제에서 구한 답을 병합
		3) BaseCase : 더이상 분할하지 않고 바로 풀 수 있는 작은 문제

	<접근방법 *************중요************>
		1) 큰 입력에 대해 동작하는 효율적 알고리즘을 처음부터 새로 만들기
		2) 작은 입력에서만 동작하는 단순한 알고리즘에서 최적화

	<Tip>
		1) 분할시, 나누어 떨어지지 않는 경우를 항상 염두에 두어야 함
			* 때로는 반으로 나누는게 더 비효율적일때도 있으니, 논리 정리 후 코딩 ㄱ
		2) 분할 방법에 따라 시간복잡도 천차만별..!

	<문제풀며 얻은 Tip>
		※ BaseCase를 먼저 정해놓고 확장해 가는게 코드짜기 훨~~~씬 쉽다!!!!
		※ 알고리즘을 명확히 글로 (pseudoCode) 써놓고 풀면, 놓치기 쉬운부분을 놓치지 않을 수 있다.



2. 카라츠바 알고리즘 (Karatsuba's Algorithm)
	: 곱셈을 분할정복으로 해결하는 알고리즘

	* N자리 정수 a, b에 대하여
	1) 정수 a,b의 상위 N/2자리를 a1, b1
	   정수 a,b의 하위 N/2자리를 a0, b0
	   로 둔다.

	// 자리수를 의미하는 10^(2/N) = K로 둔다
	2) a*b = (a1K + a0)(b1K + b0) = a1K*b1K + a1K*b0 + a0*b1K + a0b0 로 나타낼 수 있다.

	   식을 정리하면, 
	   a1b1(K^2) + (a1b0 + a0b1)K + a0b0가 된다.
	   * K는 자릿수를 올리기 위한 곱이므로, shift 연산으로 처리 가능

	3) 이때 곱 연산을 줄이기 위해 (a1b0 + a0b1)를 하나의 곱으로 바꿔 보자.

		z0 = a1b1, z1 = (a1b0 + a0b1), z2 = a0b0 라고 했을 때,
		z0와 z2를 알고 있으면, z1을 한번의 곱으로 알아낼 수 있다.
			=> (a1+a0)(b1+b0) = a1b1 + (a1b0 + a0b1) + a0b0
			=> (a1+a0)(b1+b0) = z0 + z1 + z2

			∴ z1 = (a1+a0)(b1+b0) - z0 -z2

	4) 이렇게 3곱셈을 활용하여 분할정복 하면, O(n^log3)이 된다고 한다.

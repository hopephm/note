0. Basics
	- Math
		>> Bit Operation
		>> Scales(Bin, Oct, Hex) (진법)
		>> Factorial
		>> Combination
		>> Sequence (수열)

1. Brute Force
	- DFS : 재귀구조, 기저조건, 종료조건, 호출조건
	- BFS : 큐, 각 확장 단계(Depth)를 활용할 때 좋음
	- 조합 : 재귀 구조로 순서대로 조합을 만들어가는 방법( start값, 현재 선택된 값을 넘겨 줆으로써)

2. DP
	- 중복 회피

	- 일차원 점화식
		>> LIS : 최장 증가, 감소 수열을 응용할 때 사용, 조건있는 부분 정렬로 보면 됨

	- 이차원 점화식
		>> LCS
3. 정렬

4. 그리디


5. 투 포인터


6. MinDist
	- Dijkstra
		<목적>
		>> 특정 점에서 모든 점까지의 최단거리 구할 때 사용
		>> 모든 점에서 특정 점으로의 최단거리 구할 때 사용

		<원리>
		>> 원하는 정점에서 시작하여 가장 거리가 가까운 정점 순으로 인접한 정점에 대한 거리 계산 후 현재 계산 값보다 작다면 갱신 후 조사

		<구현>
		>> 우선순위 큐를 활용, 큐에 최초 정점을 넣은 뒤 이후 최단거리가 갱신될 때마다 해당 정점과 최단거리를 우선순위 큐에 Push, 최단거리가 짧은 정점부터 검사 (중복계산 회피 목적 - 혹은 가지치기의 일종)

		>> 모든 간선의 방향을 반대로 바꾼 그래프를 활용해 각 점에서 원하는 정점으로의 최단거리를 구할 수 있음


	- Bellman_Ford
		<목적>
		>> 특정 점에서 모든 점까지의 최단거리 구할 때 사용
		>> 모든 점에서 특정 점으로의 최단거리 구할 때 사용
		>> 음의 간선이 포함된 최단거리 구할 때사용

		<원리>
		>> 다익스트라와 달리, 더 높은 최단 거리를 갖는 방향도 음의 간선과 연결되어 있어 최종 비용이 더 작아질 수 있기 때문에, 모든 정점에서 가능한 모든 거리를 체크하여 최단거리를 구함
		>> 음의 사이클이 존재할 경우, 비용이 무한정 줄어들 수 있는데, 정점 수 만큼 반복했을 때 마지막 반복문에서 값이 갱신된다면 음의 사이클이 존재하는 것으로 판단
			* 최단 경로는 같은 정점을 두번 지날 일이 없기 때문에

		<구현>
		>> 2중 반복문을 통해 가능한 모든 경우를 체크
		>> 음의 가중치 값이 정점수 -1 만큼 더해지는 것이 최대 음의 값이라 음의 오버플로우가 발생할 가능성이 매우 높다. 

	- Floyd_Warshall
		<목적>
		>> 모든 점 간의 최단거리를 구할 때 사용

		<원리>
		>> 현재 계산된 최단 거리에서 다른 곳을 거쳤을 때 더 짧아질 수 있는가? 를 판단

		<구현>
		>> 3중 반복문으로 구현




6. MinSpanningTree
	- Kruskal

	- Prim

		* Union Find
>> LIS  (Longest Increasing Sequence)

	[ O (N^2) ]

		<원리>
			>> 현재 값이 앞에서 계산된 가장 긴 증가수열의 최종 값 보다 크다면, 이 값은 가장 긴 증가수열의 뒤에 붙을 수 있고 이것이 이전에 계산된 가장 긴 증가수열보다 긴 증가수열이다.

		<구현>
			>> dp에 저장되는 값 : 해당 값에서 가질 수 있는 가장 긴 증가수열의 길이 (최초값 = 1)
			>> 2중 반복문으로 구현
			>> 모든 원소를 거치며 현재 값과 지금까지의 값을 비교하고, 현재 값이 더 크다면, 해당 값이 갖는 dp값 뒤에 현재 값이 붙을 수 있다는 뜻이므로, 현재 dp값 보다 + 1을 했을 때 더 크다면 해당값을 현재 dp 값에 저장

		ex) 수열(seq) : 10 20 10 30 50 20
			>> dp[0] = 1;
			>> for(int i = 1; i < seq.size; i++) 동안 진행
			>> 		for(int j = 0; j < i; j++) 동안 진행

			i == 1, j==0 : seq[j] = 10, 이므로 seq[i] 인 20 보다 작으므로 현재 seq[i]는 seq[0]이 갖는 최장증가수열 뒤에 붙을 수 있다. 따라서 dp[i] = dp[j] + 1

			i == 2, j==0 : seq[j] = 10, 이므로 seq[i] 인 10과 같다 따라서 최장 증가수열 뒤에 붙을 수 없으므로 갱신하지 않는다.

			i == 2, j== 1: seq[j] = 20, 이므로 seq[i] 인 10보다 크다 따라서 최장 증가수열 뒤에 붙을 수 없으므로 dp[j] 값을 갱신하지 않는다.

			* 반복문 종료시 까지 갱신된 값이 하나도 없으므로, 현재 값밖에 오지 못한다는 뜻이므로 1을 dp[i]에 기록한다.

			이하 반복

	[ O (NlogN) ]
		* lower_bound 활용가능

		<원리> 
			>> 등장하는 수가 최장 수열에서 몇번째 위치에 존재할 수 있는가? 를 가장 값이 작은 수로 유지
			>> 이렇게 유지하면 다음 오는 수가 확장 가능한지 여부를 판단할 수 있음

		<구현>
			>> dp에 저장되는 값 : 각 n번째 요소로 존재가능한 가장 작은 값
			* 그러나 해당 방법은 n번째 요소에 해당하는 LIS를 의미하는 것이 아니라 단순 갯수만을 찾아내게 되므로 별도의 값 저장이 필요함


	[ 유형 ]
		>> 증가하다가 감소하는 부분수열 혹은 감소하다가 증가하는 부분수열
			: 각 방향으로 LIS를 구한 뒤 두 값을 더한게 가장 큰 부분을 사용

		>> 앞 뒤로 더하는 문제 (백준 4198 열차정렬)
			: 중복이 없다면 lis + lds -1 로 해결 가능(-1은 기준점을 의미) 
			: 단, 모든 시작점을 기준으로 해보아야 알 수 있음.

		>> 최대 공통 증가 수열
			: 논리적 소거를 통한 계산.. (단순 검색은 N^4의 소요..)
